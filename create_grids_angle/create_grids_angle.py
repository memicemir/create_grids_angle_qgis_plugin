# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CreateGridsAngle
                                 A QGIS plugin
 Create grids under specific angle
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-01
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Memic Emir
        email                : emir_memic@windowslive.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .create_grids_angle_dialog import CreateGridsAngleDialog
import os.path

from qgis.core import *
from qgis.utils import *
from qgis.PyQt import *
import qgis.utils
import re
import processing
from qgis.utils import reloadPlugin
import math
import numpy as np
from PyQt5.QtGui import QFont, QColor
from PyQt5.QtCore import Qt

class CreateGridsAngle:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CreateGridsAngle_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Create Grids Angle')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CreateGridsAngle', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/create_grids_angle/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Create grids angle'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Create Grids Angle'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = CreateGridsAngleDialog()

#
#### me
        reloadPlugin('create_grids_angle')
        
        #self.dlg.pushButton.clicked.connect(self.split_into_grids)
        #self.dlg.pushButton_2.clicked.connect(self.rotate_grids)
        #self.dlg.pushButton_3.clicked.connect(self.move_grids)        
        self.dlg.pushButton_4.clicked.connect(self.create_layer_for_line)
        self.dlg.pushButton_5.clicked.connect(self.create_layer_for_polygon)
        self.dlg.pushButton_6.clicked.connect(self.automatically_create_grids)        
        self.dlg.pushButton_7.clicked.connect(self.guide_to_user)
        #self.dlg.pushButton_8.clicked.connect(self.setting_up_crs)
        self.dlg.listWidget.clicked.connect(self.setting_up_crs)
        
        # add available layers into interface
        layers = self.iface.mapCanvas().layers()
        self.dlg.listWidget.clear()
        listOfLayers = []
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                
                feature = layer.getFeatures()
                for featt in feature:
                    geom = featt.geometry()
                    if geom.type() == QgsWkbTypes.PolygonGeometry:                
                        #not sure if this is good solution...               
                        if '_grided_cliped' not in str(layer.name()):
                            listOfLayers.append(str(layer.name()))
            QCoreApplication.processEvents()
        self.dlg.listWidget.addItems(listOfLayers)
        

        # add available line type layers into interface
        layersS = self.iface.mapCanvas().layers()
        self.dlg.listWidget_2.clear()
        listOfLayersS = []
        for layerS in layersS:
            if layerS.type() == QgsMapLayer.VectorLayer:
                #print ('layerS type', layerS.type())                
                featureM = layerS.getFeatures()
                for feat in featureM:
                    geomM = feat.geometry()
                    if geomM.type() == QgsWkbTypes.LineGeometry:                
                        listOfLayersS.append(str(layerS.name()))
                    QCoreApplication.processEvents()        
            QCoreApplication.processEvents()
        
        self.dlg.listWidget_2.addItems(listOfLayersS)
        
        self.dlg.listWidget_2.clicked.connect(self.extend_field_edge_line)
        
#

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def guide_to_user(self):
        QMessageBox.information(None, 'Guide to user!', 
        '1. Input layer - Field Bounds (Polygon type shape file) based on which site-specific units/grids are created!\n'        
        + '   - by selecting other layer available in QGIS layers form the list window of Create Grids Angle interface, a user can automatically take over CRS, or enter it manually.\n'
        + '   - a user can use "Draw field outter bounds" to draw new temporary polygon layer of corresponding field.\n\n'        
        + '2. Input layer - Field edge (Line type) parallel to tractor tracks (Line type shape file).\n'
        + '   - a user can use "Draw field edge" push button to add new temporary line layer indicating desired field edge.\n\n'
        + '3. Polygon (site-specific) units dimensions width*height (size) in meter.\n\n'
        + '4. Create Grids.\n\n'         
        )   

    def setting_up_crs(self):
        selectedLayer = str(self.dlg.listWidget.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        layer1=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        print ('layer', layer)
        myfilepathP = layer.source()
        myfilepathP = os.path.dirname(myfilepathP)
        print ('myfilepathP', myfilepathP)

        lyrCRS = layer.crs().authid() # returns a reference to the active QgsMapLayer
        print('lyrCRS', lyrCRS)
        self.dlg.lineEdit_3.setText(lyrCRS)

    def automatically_create_grids(self):
        self.split_into_grids()
        self.rotate_grids()
        self.move_grids()
        
        lineEdgeHorizontalTest = 'lineEdgeHorizontalTest'
        input_layer0 = QgsProject.instance().mapLayersByName(lineEdgeHorizontalTest)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        lineEdgeTest = 'lineEdgeTest'
        input_layer0 = QgsProject.instance().mapLayersByName(lineEdgeTest)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        findEdgeOfFieldBound = 'findEdgeOfFieldBound'
        input_layer0 = QgsProject.instance().mapLayersByName(findEdgeOfFieldBound)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        foundRightEdgeIntersect = 'foundRightEdgeIntersect'
        input_layer0 = QgsProject.instance().mapLayersByName(foundRightEdgeIntersect)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        coordinate_0 = 'coordinate_0'
        input_layer0 = QgsProject.instance().mapLayersByName(coordinate_0)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        coordinate_1 = 'coordinate_1'
        input_layer0 = QgsProject.instance().mapLayersByName(coordinate_1)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        coordinate_2 = 'coordinate_2'
        input_layer0 = QgsProject.instance().mapLayersByName(coordinate_2)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        coordinate_3 = 'coordinate_3'
        input_layer0 = QgsProject.instance().mapLayersByName(coordinate_3)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)         
        QgsProject.instance().removeMapLayer(input_layer0)
        
        centerOfGriddedBoundingBox = 'centerOfGriddedBoundingBox'
        input_layer0 = QgsProject.instance().mapLayersByName(centerOfGriddedBoundingBox)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        selectedLayer = str(self.dlg.listWidget.currentItem().text())

        originalcopy = selectedLayer + '_original-copy'
        input_layer0 = QgsProject.instance().mapLayersByName(originalcopy)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)
        
        grided = selectedLayer + '_grided'
        input_layer0 = QgsProject.instance().mapLayersByName(grided)[0]            
        #QgsProject.instance().layerTreeRoot().findLayer(input_layer0).setItemVisibilityChecked(False)
        QgsProject.instance().removeMapLayer(input_layer0)


    def create_layer_for_polygon(self):
        print ('create polygon - field bounds')
        # try:
            # self.dlg.listWidget.setCurrentRow(0)
            # selectedLayer = str(self.dlg.listWidget.currentItem().text())
            # layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
            # layer1=QgsProject.instance().mapLayersByName(selectedLayer)[0]
            # print ('layer', layer)
            # myfilepathP = layer.source()
            # myfilepathP = os.path.dirname(myfilepathP)
            # print ('myfilepathP', myfilepathP)
        # except:
        selectedLayer = 'Field'
        #lyrCRS = layer.crs().authid() # returns a reference to the active QgsMapLayer
        #print('lyrCRS', lyrCRS)
        #self.dlg.lineEdit_3.setText(lyrCRS)
        lyrCRS = str(self.dlg.lineEdit_3.text())
        print('lyrCRS', lyrCRS)

        newLineLayer = QgsVectorLayer("Polygon?crs=" + str(lyrCRS), str(selectedLayer) + '-fieldBoundsTest', "memory")
        
        #newLineLayer.startEditing()
        #qgis.utils.iface.actionAddFeature().trigger()

        def feature_added():            
            newLineLayer.featureAdded.disconnect() # Disconnect from the signal            
            newLineLayer.commitChanges()  # Save changes and end edit mode

            self.dlg.listWidget.clear()
            layers = self.iface.mapCanvas().layers()
            listOfLayers = []
            for layer in layers:
                if layer.type() == QgsMapLayer.VectorLayer:

                    feature = layer.getFeatures()
                    for featt in feature:
                        geom = featt.geometry()
                        if geom.type() == QgsWkbTypes.PolygonGeometry:                
                            #listOfLayersS.append(str(layerS.name())) 

                            listOfLayers.append(str(layer.name()))
                QCoreApplication.processEvents()
            self.dlg.listWidget.addItems(listOfLayers)
            #iface.setActiveLayer(layer1)

            try:
                nameToSelectAuto = str(selectedLayer) + '-fieldBoundsTest'
                print ('nameToSelectAuto', nameToSelectAuto)
                setAutoSelction = self.dlg.listWidget.findItems(str(nameToSelectAuto),Qt.MatchExactly)
                print ('row to select - check', setAutoSelction)
                if len(setAutoSelction)>0:
                    print ('row to select - check')
                    for selectMe in setAutoSelction:
                        
                        rowToSelect = int(self.dlg.listWidget.row(selectMe))
                        print ('row to select', rowToSelect)
                        self.dlg.listWidget.setCurrentRow(rowToSelect)
            except:
                print ('failed auto selection of field bunds in listwidget')
    
        newLineLayer.featureAdded.connect(feature_added) # Connect the layer to the signal featureAdded, so when a feature is added to the layer, the feature_added function is called         
        newLineLayer.startEditing() # Set the layer in edit mode        
        iface.actionAddFeature().trigger()  # Activate the QGIS add feature tool
        
        QgsProject.instance().addMapLayer(newLineLayer)

        newLineLayer.triggerRepaint()

        #newLineLayer.renderer().symbol().setColor(QColor.fromRgb(255, 0, 0))
        #newLineLayer.renderer().symbol().setOpacity(0.25) #setWidth(0.5)
        newLineLayer.renderer().symbol().setColor(QColor("transparent"))
        newLineLayer.renderer().symbol().symbolLayer(0).setStrokeColor(QColor("red")) #setStrokeColor(QColor("black"))
        newLineLayer.renderer().symbol().symbolLayer(0).setStrokeWidth(0.5) #setWidth(3)

        newLineLayer.triggerRepaint()
        QgsProject.instance().reloadAllLayers()
        


    def create_layer_for_line(self):
        print ('create line')

        selectedLayer = str(self.dlg.listWidget.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        layer1=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        print ('layer', layer)
        myfilepathP = layer.source()
        myfilepathP = os.path.dirname(myfilepathP)
        print ('myfilepathP', myfilepathP)

        #lyrCRS = layer.crs().authid() # returns a reference to the active QgsMapLayer
        #print('lyrCRS', lyrCRS)
        lyrCRS = str(self.dlg.lineEdit_3.text())
        print('lyrCRS', lyrCRS)
        
        #provider = layer.dataProvider()
        #writer1 = QgsVectorFileWriter("layerAbove15Name.shp", "CP1250", provider.fields(), provider.geometryType(), provider.crs(), "ESRI Shapefile")
        #newLineLayer = QgsVectorLayer("LineString",str(selectedLayer) + '-fieldEdge', "memory")
        #newLineLayer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(selectedLayer) + '-fieldEdge', "memory")
        newLineLayer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(selectedLayer) + '-fieldEdge', "memory")
        
        #newLineLayer.startEditing()
        #qgis.utils.iface.actionAddFeature().trigger()

        def feature_added():            
            newLineLayer.featureAdded.disconnect() # Disconnect from the signal            
            newLineLayer.commitChanges()  # Save changes and end edit mode

            self.dlg.listWidget_2.clear()
            # layers = self.iface.mapCanvas().layers()
            # listOfLayers = []
            # for layer in layers:
                # listOfLayers.append(str(layer.name()))
                # QCoreApplication.processEvents()
            # self.dlg.listWidget_2.addItems(listOfLayers)
            
            # add available line type layers into interface
            layersS = self.iface.mapCanvas().layers()
            listOfLayersS = []
            for layerS in layersS:
                if layerS.type() == QgsMapLayer.VectorLayer:
                    #print ('layerS type', layerS.type())                
                    featureM = layerS.getFeatures()
                    for feat in featureM:
                        geomM = feat.geometry()
                        if geomM.type() == QgsWkbTypes.LineGeometry:                
                            listOfLayersS.append(str(layerS.name()))
                        QCoreApplication.processEvents()    
                QCoreApplication.processEvents()
            
            self.dlg.listWidget_2.addItems(listOfLayersS)            
            
            
            
            iface.setActiveLayer(layer1)

            try:
                nameToSelectAuto = str(selectedLayer) + '-fieldEdge'
                print ('nameToSelectAuto', nameToSelectAuto)
                setAutoSelction = self.dlg.listWidget_2.findItems(str(nameToSelectAuto),Qt.MatchExactly)
                print ('row to select - check', setAutoSelction)
                if len(setAutoSelction)>0:
                    print ('row to select - check')
                    for selectMe in setAutoSelction:
                        
                        rowToSelect = int(self.dlg.listWidget_2.row(selectMe))
                        print ('row to select', rowToSelect)
                        self.dlg.listWidget_2.setCurrentRow(rowToSelect)
                        QCoreApplication.processEvents()
                        self.extend_field_edge_line()
            except:
                print ('failed auto selection of field bunds in listWidget_2')
    
        newLineLayer.featureAdded.connect(feature_added) # Connect the layer to the signal featureAdded, so when a feature is added to the layer, the feature_added function is called         
        newLineLayer.startEditing() # Set the layer in edit mode        
        iface.actionAddFeature().trigger()  # Activate the QGIS add feature tool
        
        QgsProject.instance().addMapLayer(newLineLayer)

        newLineLayer.renderer().symbol().setWidth(0.5)
        newLineLayer.renderer().symbol().setColor(QColor.fromRgb(0, 0, 0))

        newLineLayer.triggerRepaint()
        
        

    def extend_field_edge_line(self):

        selectedLayer = str(self.dlg.listWidget.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        iface.setActiveLayer(layer) 
        
        # improve this 
        findLongestLine = []
        for feature in layer.getFeatures():
            i = 0
            for v in feature.geometry().vertices():
                i += 1
                x = v.x()
                y = v.y()
                #print (i, x, y)
                
                if i >= 2:
                    print ('x', x, 'y', y)
                    print ('x1', x1, 'y1', y1)
                    print ('distance', math.dist([x,y], [x1,y1]))
                    findLongestLine.append(float(math.dist([x,y], [x1,y1])))
                x1 = x
                y1 = y
        findLongestLineFound = max(findLongestLine)
        print ('findLongestLineFound', findLongestLineFound)
        
        self.findLongestLineFoundUseLater = findLongestLineFound
        
        # extend line
        selectedLayer = str(self.dlg.listWidget_2.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        iface.setActiveLayer(layer) 

        lengthExtend = findLongestLineFound/2 #100.0
        print ('lengthExtend', lengthExtend)

        def extend_line(feat, length):        
            g = feat.geometry()
            v = [v for v in g.vertices()]
            #n = g.extendLine(float(length), 0.0)
            n = g.extendLine(0.0, float(length))
            return QgsGeometry(n)        
        
        layer.selectByIds([1])
        with edit(layer):
            for f in layer.selectedFeatures():
                layer.changeGeometry(f.id(), extend_line(f, lengthExtend))
            for f in layer.selectedFeatures():
                layer.changeGeometry(f.id(), extend_line(f, lengthExtend))                
                         
        #retrieve feature geometry and check its new length
        f = layer.getFeature(1)
        print(f.geometry().length())
        #layer.commitChanges()
        layer.triggerRepaint()

        def extend_line(feat, length):        
            g = feat.geometry()
            v = [v for v in g.vertices()]
            n = g.extendLine(float(length), 0.0)
            #n = g.extendLine(0.0, float(length))
            return QgsGeometry(n)        
        
        layer.selectByIds([1])
        with edit(layer):
            for f in layer.selectedFeatures():
                layer.changeGeometry(f.id(), extend_line(f, lengthExtend))
            for f in layer.selectedFeatures():
                layer.changeGeometry(f.id(), extend_line(f, lengthExtend))                
                         
        #retrieve feature geometry and check its new length
        f = layer.getFeature(1)
        print(f.geometry().length())
        #layer.commitChanges()
        layer.triggerRepaint()





    def split_into_grids(self):

        #self.dlg.textBrowser.append('split into grids') 

        selectedLayer = str(self.dlg.listWidget.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        iface.setActiveLayer(layer)



        # automatically select area based of selected layer in list of layers
        activeLayer = self.iface.activeLayer()
        for feature in activeLayer.getFeatures():
            activeLayer.select(feature.id())

# center of field bounds
        ##############
        features = layer.selectedFeatures()
        for f in features:
            #geom = f.geometry()
            #print ('geom', geom)        
            centerOfPolygon = f.geometry().centroid().asPoint()
            print ('centerOfPolygon', centerOfPolygon)
# center of field bounds


# field edge line
        keepLayerName = str(self.dlg.listWidget_2.currentItem().text())       
        layer = QgsProject.instance().mapLayersByName(keepLayerName)[0]
        
        #layer = iface.activeLayer()
        #selected = layer.selectedFeatures()
        for feature in layer.getFeatures():
            meI = 0
            for v in feature.geometry().vertices():
                #print ('x1', v.x())
                #print ('y1', v.y())
                if meI == 0:
                    #x1 = v.x()
                    #y1 = v.y()
                    meX1 = v.x()
                    meY1 = v.y()                    
                if meI == 1:
                    #x2 = v.x()
                    #y2 = v.y()
                    meX2 = v.x()
                    meY2 = v.y()                       
                meI = meI + 1
        print ('me----difMeC:', meX1, meY1, meX2, meY2)
        #difMeC = (y2-y1)/(x2-x1)
        difMeC = (meX2-meX1)    
        print ('me----difMeC:', difMeC)
        difMeCy = (meY2-meY1)    
        print ('me----difMeC Y:', difMeCy)

        # x1 = meX1
        # y1 = meY1            
        # x2 = meX2
        # y2 = meY2
    
        #if difMeC >= 0:
        if meX2 < meX1:    
            x1 = meX1
            y1 = meY1            
            x2 = meX2
            y2 = meY2
            #self.horizontalSlopeCalcTrue = True    
        #if difMeC < 0:
        if meX2 > meX1:            
            x1 = meX2
            y1 = meY2            
            x2 = meX1
            y2 = meY1
            #self.horizontalSlopeCalcTrue = False 
# field edge line

#test
        def slopeTest(x1, y1, x2, y2): 
            return (y2-y1)/(x2-x1)
        def angleTest(s1, s2): 
            return math.degrees(math.atan((s2-s1)/(1+(s2*s1))))            
            
        lineATest = ((x1, y1), (x2, y2))
        lineBTest = ((x1, y1), (x2, y1))  

        slope1Test = slopeTest(lineATest[0][0], lineATest[0][1], lineATest[1][0], lineATest[1][1])
        slope2Test = slopeTest(lineBTest[0][0], lineBTest[0][1], lineBTest[1][0], lineBTest[1][1])        

        angTest = angleTest(slope1Test, slope2Test)
# not good

        def slopeCheckHV(x1, x2, y1, y2):
            s = (abs(y2)-abs(y1))/(abs(x2)-abs(x1))
            return s
                    
        # print ('lineEdgeSlope', slopeCheckHV(x1, y1, x2, y2))
        # print ('lineEdgeSlopeHorizontal', slopeCheckHV(x_min, y_min, x_max, y_min))
        # print ('lineEdgeSlopeVertical', slopeCheckHV(x_min, y_min, x_min, y_max))        
        
        slopeChekcForLater = slopeCheckHV(x1, y1, x2, y2)
        print('slopeChekcForLater in = ', slopeChekcForLater)
        slopeChekcForLaterDegre = math.sin(math.radians(slopeChekcForLater))
        print('slopeChekcForLaterDegre in = ', slopeChekcForLaterDegre)
        # self.horizontalSlopeCalcTrue = True
        # if slopeChekcForLater > 1.0:
            # self.horizontalSlopeCalcTrue = False


        angTest = angTest #* (-1) #+90
        # if slopeChekcForLater > 1.0:
            # angTest = angTest + 90
        self.angTest = angTest
        print('AngleTest in = ', angTest)

        # just for checking
        #lyrCRS = layer.crs().authid() # returns a reference to the active QgsMapLayer
        lyrCRS = str(self.dlg.lineEdit_3.text())
        print('lyrCRS', lyrCRS)

        v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), 'lineEdgeTest', "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        #v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(selectedLayer), "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        v_layer.startEditing()

        pr = v_layer.dataProvider()
        seg = QgsFeature()

        start_point = QgsPoint(x1, y1)
        end_point = QgsPoint(x2, y2)
        #add first line
        seg.setGeometry(QgsGeometry.fromPolyline([start_point, end_point]))
        pr.addFeatures([ seg ])
        v_layer.commitChanges()
        v_layer.triggerRepaint()
        QgsProject.instance().addMapLayers([v_layer])

        v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), 'lineEdgeHorizontalTest', "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        #v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(selectedLayer), "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        v_layer.startEditing()

        pr = v_layer.dataProvider()
        seg = QgsFeature()

        start_point = QgsPoint(x1, y1)
        end_point = QgsPoint(x2, y1)
        #add first line
        seg.setGeometry(QgsGeometry.fromPolyline([start_point, end_point]))
        pr.addFeatures([ seg ])
        v_layer.commitChanges()
        v_layer.triggerRepaint()
        QgsProject.instance().addMapLayers([v_layer])

        # just for checking

        selectedLayer = str(self.dlg.listWidget.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        iface.setActiveLayer(layer)


        ##############
        features = layer.selectedFeatures()
        for f in features:
            #geom = f.geometry()
            #print ('geom', geom)        
            centerOfPolygonTest = f.geometry().centroid().asPoint()
            print ('centerOfPolygonTest', centerOfPolygonTest)


        #layer.selectAll()
        clone_layer = processing.run("native:saveselectedfeatures", {'INPUT': layer, 'OUTPUT': 'memory:{}'.format(str(selectedLayer)+'_original-copy')})['OUTPUT']
        #layer.removeSelection()
        QgsProject.instance().addMapLayer(clone_layer)       

        selectedLayer = str(self.dlg.listWidget.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer + '_original-copy')[0]
        iface.setActiveLayer(layer)


        ##############
        features = layer.selectedFeatures()
        for f in features:
            #geom = f.geometry()
            #print ('geom', geom)        
            centerOfPolygonTest = f.geometry().centroid().asPoint()
            print ('centerOfPolygonTest', centerOfPolygonTest)

        # this was outcommented beacause now i am inflating artificially bounding box and dont have to rotate origianl 
        # provider = layer.dataProvider()
        # couples_id_geom = []
        # for feature in layer.getFeatures():
            # geom = feature.geometry()
            # centroid = QgsPointXY(centerOfPolygonTest) #xMe, yMe) #feature.geometry().centroid().asPoint()
            # #centroid = feature.geometry().centroid().asPoint()
            # #print ('centroid me as centar of all selected feature', centroid)
            # #geom.rotate(rotation, centroid)
            # geom.rotate(angTest, centroid)
            # # accumulate args to avoid rotation feature by feature
            # couples_id_geom.append([feature.id(), geom])

        # # Change the layer features rotation in one go
        # provider.changeGeometryValues({couple_id_geom[0]: couple_id_geom[1] for couple_id_geom in couples_id_geom})


# test        

  
        #result=processing.run("native:buffer",{'INPUT':activeLayer,
        #                                        'DISTANCE' : 100,
        #                                        'OUTPUT':'memory:'})
        #QgsProject.instance().addMapLayer(result['OUTPUT'])                                        

        #the spacing of the cut grid
        horizontalSpacing = float(self.dlg.lineEdit.text()) #10
        verticalSpacing = float(self.dlg.lineEdit_2.text()) #10

        selectedLayer = str(self.dlg.listWidget.currentItem().text())
        layer=QgsProject.instance().mapLayersByName(selectedLayer)[0]
        iface.setActiveLayer(layer)


        #get current layer, selection, CRS from QGIS map canvas
        layer = qgis.utils.iface.activeLayer()
        selected = layer.selectedFeatures()
        crs = qgis.utils.iface.activeLayer().crs().authid()



        for feature in selected:
            #get the ID of the feature we've selected in QGIS map canvas
            #id = feature.id
            #print("working on: " + str(id))

            #get the extent of the selected feature
            #x_max, y_max, x_min, y_min = re.split(":|,",  feature.geometry().boundingBox().toString().replace(" ", ""))
            x_min, y_min, x_max, y_max = re.split(":|,",  feature.geometry().boundingBox().toString().replace(" ", ""))

        ## this might cause problems in some casees - pull it into checkbox condition MAYBE....
            x_min = str(float(x_min) - self.findLongestLineFoundUseLater/2)
            y_min = str(float(y_min) - self.findLongestLineFoundUseLater/2) 
            
            x_max = str(float(x_max) + self.findLongestLineFoundUseLater/2)
            y_max = str(float(y_max) + self.findLongestLineFoundUseLater/2)
            
            extent = x_min + "," + x_max + "," + y_min + "," + y_max
            print('extent----------', extent)
            
            # heightMe = float(y_max)-float(y_min)
            # widthMe = float(x_max)-float(x_min)
            # print('heightMe', str(heightMe))
            # print('widthMe', str(widthMe))
            
            # self.countFahrGme = heightMe/verticalSpacing
            # print('countFahrGme', str(self.countFahrGme))
            
            #create our grid in memory - type 2 refers to rectangle
            grid_parameters = {"TYPE":  2,
                                            "EXTENT": extent,
                                            "HSPACING": horizontalSpacing,
                                            "VSPACING": verticalSpacing,
                                            "HOVERLAY": 0,
                                            "VOVERLAY": 0,
                                            "CRS": crs,
                                            "OUTPUT": "memory"}

            out1 = processing.run('native:creategrid', grid_parameters)

            #grid = QgsVectorLayer(out1['OUTPUT'], 'gridMe', 'ogr')
            grid = QgsVectorLayer(out1['OUTPUT'], str(activeLayer.name()) + '_grided', 'ogr')
            QgsProject().instance().addMapLayer(grid)


        self.dlg.x_min = float(x_min)   #(x_min)
        self.dlg.y_min = float(y_min)   #(y_min)
        self.dlg.x_max = float(x_max)   #(x_max)
        self.dlg.y_max = float(y_max)   #(y_min)  

        keepLayerName = str(self.dlg.listWidget.currentItem().text())       
        layer = QgsProject.instance().mapLayersByName(keepLayerName + '_grided')[0]
        iface.setActiveLayer(layer)
        print('extent------real----')
        print ('layer', layer)
        ext = layer.extent()
        print('extent------real----', ext)
        x_min = ext.xMinimum()
        y_min = ext.yMinimum()
        x_max = ext.xMaximum()
        y_max = ext.yMaximum()


        # def slopeCheckHV(x1, x2, y1, y2):
            # s = (abs(y2)-abs(y1))/(abs(x2)-abs(x1))
            # return s
                    
        # print ('lineEdgeSlope', slopeCheckHV(x1, y1, x2, y2))
        # print ('lineEdgeSlopeHorizontal', slopeCheckHV(x_min, y_min, x_max, y_min))
        # print ('lineEdgeSlopeVertical', slopeCheckHV(x_min, y_min, x_min, y_max))        
        
        # slopeChekcForLater = slopeCheckHV(x1, y1, x2, y2)

        
        # self.horizontalSlopeCalcTrue = True
        # if slopeChekcForLater > 1.0:
            # self.horizontalSlopeCalcTrue = False

        #print ('WORKING SLOPE HORIZONTAL', self.horizontalSlopeCalcTrue)
        
# rotate back to origianl

        keepLayerName = str(self.dlg.listWidget.currentItem().text())       
        layer = QgsProject.instance().mapLayersByName(keepLayerName + '_grided')[0]

        angTest = angTest #*(-1)

        provider = layer.dataProvider()
        couples_id_geom = []
        for feature in layer.getFeatures():
            geom = feature.geometry()
            centroid = QgsPointXY(centerOfPolygonTest) #xMe, yMe) #feature.geometry().centroid().asPoint()
            #centroid = feature.geometry().centroid().asPoint()
            #print ('centroid me as centar of all selected feature', centroid)
            #geom.rotate(rotation, centroid)
            geom.rotate(angTest, centroid)
            # accumulate args to avoid rotation feature by feature
            couples_id_geom.append([feature.id(), geom])

        # Change the layer features rotation in one go
        provider.changeGeometryValues({couple_id_geom[0]: couple_id_geom[1] for couple_id_geom in couples_id_geom})

# rotate back to origianl




        #self.dlg.xMe = (float(x_max)+float(x_min))/2
        #self.dlg.yMe = (float(y_max)+float(y_min))/2   
        
        # self.dlg.x1MeAngle = float(x_max)   #(x_min)
        # self.dlg.y1MeAngle = float(y_max)   #(y_min)
        # self.dlg.x2MeAngle = float(x_min)   #(x_max)
        # self.dlg.y2MeAngle = float(y_max)   #(y_min)      

        # self.dlg.x_min = float(x_min)   #(x_min)
        # self.dlg.y_min = float(y_min)   #(y_min)
        # self.dlg.x_max = float(x_max)   #(x_max)
        # self.dlg.y_max = float(y_max)   #(y_min)  

        #self.pointsCehck = [[self.dlg.x_min, self.dlg.y_min],[self.dlg.x_max, self.dlg.y_min],[self.dlg.x_max, self.dlg.y_max],[self.dlg.x_min, self.dlg.y_max]]
        #print ('pointsCehck', self.pointsCehck)


        # heightMe = float(self.dlg.y_max)-float(self.dlg.y_min)
        # self.countFahrGme = heightMe/verticalSpacing
        # print('countFahrGme', str(self.countFahrGme))        
        
        # counter = math.ceil(abs(self.countFahrGme)) *(-1)
        # self.addingForExtension = counter * verticalSpacing #float(self.dlg.lineEdit_2.text())
        
    
        # if self.horizontal == False:
            # widthMe = float(self.dlg.x_max)-float(self.dlg.x_min)

            # self.countFahrGme = widthMe/horizontalSpacing
            # print('countFahrGme', str(self.countFahrGme))  

            # counter = math.ceil(abs(self.countFahrGme)) *(-1)
            # self.addingForExtension = counter * horizontalSpacing #float(self.dlg.lineEdit.text())
     
        # print('countFahrGme use to move', str(self.countFahrGme)) 



        #self.lenghtMe = heightMe
            
# # just for checking
        # lyrCRS = layer.crs().authid() # returns a reference to the active QgsMapLayer
        # print('lyrCRS', lyrCRS)

        # #layer =  QgsVectorLayer('Point?crs=epsg:4326', 'MyPoint' , "memory")
        # layer = QgsVectorLayer("Point?crs=" + str(lyrCRS), 'x_min,y_min', "memory")
        # pr = layer.dataProvider()
        # pt = QgsFeature()
        # point1 = QgsPointXY(self.dlg.x_min, self.dlg.y_min)  #1 correction
        # pt.setGeometry(QgsGeometry.fromPointXY(point1)) #2 correction
        # pr.addFeatures([pt])
        # layer.updateExtents()
        # QgsProject.instance().addMapLayers([layer])

        # layer = QgsVectorLayer("Point?crs=" + str(lyrCRS), 'x_max,y_max', "memory")
        # pr = layer.dataProvider()
        # pt = QgsFeature()
        # point1 = QgsPointXY(self.dlg.x_max, self.dlg.y_max)  #1 correction
        # pt.setGeometry(QgsGeometry.fromPointXY(point1)) #2 correction
        # pr.addFeatures([pt])
        # layer.updateExtents()
        # QgsProject.instance().addMapLayers([layer])
        # #self.x2biggerExtend = float(x_max)
        # #self.y2biggerExtend = float(y_max)
# # just for checking
 

    def rotate_grids(self):     
    
# these horizontal and vertical spacing are oposite for use - not an error and are used later directly for shifting grids to aligne with field edge
        horizontalSpacing = float(self.dlg.lineEdit.text()) #10
        verticalSpacing = float(self.dlg.lineEdit_2.text()) #10

        widthMe = float(self.dlg.x_max)-float(self.dlg.x_min)
        print ('width', widthMe)
        heightMe = float(self.dlg.y_max)-float(self.dlg.y_min)
        print ('height', heightMe)        
        
        countFahrGme = heightMe/verticalSpacing
        #print('countFahrGme', str(countFahrGme))  
        counter = math.ceil(abs(countFahrGme)) *(-1)
        addingForExtension = counter * verticalSpacing #* 2 #float(self.dlg.lineEdit.text())

        # if self.horizontalSlopeCalcTrue == False:        
            # #heightMe = float(self.dlg.y_max)-float(self.dlg.y_min)
            # print ('height', heightMe)
            # countFahrGme = widthMe/horizontalSpacing
            # #print('countFahrGme', str(countFahrGme))                
            # counter = math.ceil(abs(countFahrGme)) *(-1)
            # addingForExtension = counter * horizontalSpacing #* 2 #float(self.dlg.lineEdit_2.text())        
        
        # print ('counter', counter)


        print('countFahrGme', str(countFahrGme))
        print('addingForExtension', str(addingForExtension))
        self.addingForExtensionLaterMeasure = addingForExtension / 2
        
        angleMove = self.angTest #* (-1) #self.angle

        keepLayerName = str(self.dlg.listWidget.currentItem().text())       
        layer = QgsProject.instance().mapLayersByName(keepLayerName + '_grided')[0]
        #iface.setActiveLayer(layer)


        x = []
        y = []
        for f in layer.getFeatures():
            feat = QgsFeature()
            pt = f.geometry().centroid().asPoint()
            #print ('pt', pt[0], pt[1])
            x.append(float(pt[0]))
            y.append(float(pt[1]))
        
        xc, yc = sum(x)/len(x), sum(y)/len(y)
        print ('center', xc, yc)


        #lyrCRS = layer.crs().authid() # returns a reference to the active QgsMapLayer
        #print('lyrCRS', lyrCRS)
        lyrCRS = str(self.dlg.lineEdit_3.text())
        print('lyrCRS', lyrCRS)

        #layer =  QgsVectorLayer('Point?crs=epsg:4326', 'MyPoint' , "memory")
        layer = QgsVectorLayer("Point?crs=" + str(lyrCRS), 'centerOfGriddedBoundingBox', "memory")
        pr = layer.dataProvider()
        pt = QgsFeature()
        point1 = QgsPointXY(xc, yc)  #1 correction
        pt.setGeometry(QgsGeometry.fromPointXY(point1)) #2 correction
        pr.addFeatures([pt])
        layer.updateExtents()
        QgsProject.instance().addMapLayers([layer])


# ######
        # lengthExtend = 1000 #self.maxdistanceMe
        
        
        # keepLayerNameNew = str(self.dlg.listWidget_2.currentItem().text()) 
        # v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(keepLayerNameNew), "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        # #v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(selectedLayer), "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        # v_layer.startEditing()

        # # for feature in v_layer.getFeatures():
            # # meI = 0
            # # for v in feature.geometry().vertices():
                # # #print ('x1', v.x())
                # # #print ('y1', v.y())
                # # if meI == 0:
                    # # x1 = v.x()
                    # # y1 = v.y()
                # # if meI == 1:
                    # # x2 = v.x()
                    # # y2 = v.y()                                
                # # meI = meI + 1
        # # print ('me', x1, y1, x2, y2) 


        # def extend_line(feat, length):        
            # g = feat.geometry()
            # #n = g.extendLine(float(length), 0.0)
            # n = g.extendLine(float(length), 0.0)
            
            # #n = QgsLineString(v)
            # return QgsGeometry(n)        
        
        
        # #print ('idListsMe', idListsMe)
        # v_layer.selectByIds(meI) #idListsMe) #[1])
        # with edit(v_layer):
            # for f in v_layer.selectedFeatures():
                # v_layer.changeGeometry(f.id(), extend_line(f, lengthExtend))

        # v_layer.triggerRepaint()
        # QgsProject.instance().reloadAllLayers() 
# ######

        plotCoordinate = 'coordinate'
        for i in range(0,4):
            angleMove = angleMove
            print ('angle', angleMove)
            v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(plotCoordinate) + '_' + str(i) , "memory") 
            v_layer.startEditing()
            pr = v_layer.dataProvider()
            seg = QgsFeature()
            
            start_point = QgsPoint(xc, yc)             
            #new_x = xc + ((addingForExtension) /2) * math.sin(math.radians(angleMove))
            #new_y = yc + ((addingForExtension) /2) * math.cos(math.radians(angleMove)) 
            new_x = xc + ((addingForExtension)) * math.sin(math.radians(angleMove))
            new_y = yc + ((addingForExtension)) * math.cos(math.radians(angleMove))      
            
            end_point = QgsPoint(new_x, new_y)

            seg.setGeometry(QgsGeometry.fromPolyline([start_point, end_point]))
            pr.addFeatures([ seg ])
            v_layer.commitChanges()
            v_layer.triggerRepaint()
            QgsProject.instance().addMapLayers([v_layer])
            

            QgsProject.instance().reloadAllLayers()
            QCoreApplication.processEvents()
            
            layer2Name =  str(plotCoordinate) + '_' + str(i)
            print ('layer2', layer2Name)
            
            try:
                f = v_layer.getFeature(1)
                keepLayerName = str(self.dlg.listWidget_2.currentItem().text())
                layer1 = QgsProject.instance().mapLayersByName(keepLayerName)[0]
                #layer2Name =  str(plotCoordinate) + '_' + str(i)
                layer2 = QgsProject.instance().mapLayersByName(layer2Name)[0]

            
                for f in layer1.getFeatures():
                    for a in layer2.getFeatures():
                        if a.geometry().intersects(f.geometry()):
                            intersection = a.geometry().intersection(f.geometry()).asPoint()
                            print ('intersection', i)
                            print ('intersection angle', angleMove)
                            angleMoveIntersect = angleMove
                            print ('intersection angle', angleMoveIntersect)
                            
                            #check this here
                            edgelinelenghtNewDiffAgainC = float(a.geometry().length())
                            print ('edgelinelenghtNewDiffAgainC', edgelinelenghtNewDiffAgainC)                            
                            
            except:
                print ('doesnt intersect', i)
            
            QgsProject.instance().reloadAllLayers()
            QCoreApplication.processEvents()
            
            angleMove = angleMove + 90
        print ('intersection angle', angleMoveIntersect)
        self.angleMoveIntersectTest  = angleMoveIntersect
        
        v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), 'foundRightEdgeIntersect' , "memory") 
        v_layer.startEditing()
        pr = v_layer.dataProvider()
        seg = QgsFeature()
        
        start_point = QgsPoint(xc, yc)             
        #new_x = xc + ((addingForExtension) /2) * math.sin(math.radians(angleMoveIntersect))
        #new_y = yc + ((addingForExtension) /2) * math.cos(math.radians(angleMoveIntersect))
        new_x = xc + ((addingForExtension)) * math.sin(math.radians(angleMoveIntersect))
        new_y = yc + ((addingForExtension)) * math.cos(math.radians(angleMoveIntersect))          
        end_point = QgsPoint(new_x, new_y)

        seg.setGeometry(QgsGeometry.fromPolyline([start_point, end_point]))
        pr.addFeatures([ seg ])
        v_layer.commitChanges()
        v_layer.triggerRepaint()
        QgsProject.instance().addMapLayers([v_layer])        



        v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), 'findEdgeOfFieldBound', "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        #v_layer = QgsVectorLayer("LineString?crs=" + str(lyrCRS), str(selectedLayer), "memory") #QgsVectorLayer('LineString?crs=epsg:4326', 'line', 'memory')
        v_layer.startEditing()

        pr = v_layer.dataProvider()
        seg = QgsFeature()

        start_point = QgsPoint(xc, yc)
        end_point = QgsPoint(intersection)
        
        #add first line
        seg.setGeometry(QgsGeometry.fromPolyline([start_point, end_point]))
        pr.addFeatures([ seg ])
        v_layer.commitChanges()
        v_layer.triggerRepaint()
        QgsProject.instance().addMapLayers([v_layer])


        f = v_layer.getFeature(1)
        #print('needed lenght', f.geometry().length())
        edgelinelenghtNewDiffAgainCc = float(f.geometry().length())
        print ('edgelinelenghtNewDiffAgainCc', edgelinelenghtNewDiffAgainCc)



        
        # keepLayerName = str(self.dlg.listWidget.currentItem().text())       
        # layer = QgsProject.instance().mapLayersByName(keepLayerName + '_grided')[0]
        # iface.setActiveLayer(layer)
        # print ('layer', layer)
        
        #angle = self.angle
        #self.difference = edgelinelenghtNewDiffAgainC - edgelinelenghtNewDiffAgainCc #10 #self.difference #10
        self.difference =  abs(self.addingForExtensionLaterMeasure) - edgelinelenghtNewDiffAgainCc
        #difference = edgelinelenghtNewDiffAgainCc - edgelinelenghtNewDiffAgainC  #10 #self.difference #10
        print ('self.difference', self.difference)


    def move_grids(self):

        difference = self.difference
        print ('difference', difference)

        keepLayerName = str(self.dlg.listWidget.currentItem().text())       
        layer = QgsProject.instance().mapLayersByName(keepLayerName + '_grided')[0]
        iface.setActiveLayer(layer)
        print ('layer', layer)

        angleMove = self.angleMoveIntersectTest #self.angTest * (-1)
        print ('angleMove', angleMove)    
    
        for feat in layer.getFeatures():
            geom = feat.geometry()
            

            factorReduceY = math.cos(math.radians((angleMove))) * float(difference)
            factorReduceX = math.sin(math.radians((angleMove))) * float(difference) #factorReduceY

            geom.translate(factorReduceX, factorReduceY) # translation
            fid = feat.id()
            layer.dataProvider().changeGeometryValues({ fid : geom })

        layer.triggerRepaint()
        #QgsProject.instance().reloadAllLayers()            
        QgsProject.instance().reloadAllLayers()
        QCoreApplication.processEvents()        
        
# clipe the grids according to field bounds ################

        keepLayerName = str(self.dlg.listWidget.currentItem().text())
        
        input_layer = QgsProject.instance().mapLayersByName(keepLayerName + '_grided')[0]
        
        
        clipBy = str(keepLayerName) #+'_original-copy' #'output'
        keepLayer = QgsProject.instance().mapLayersByName(clipBy)[0]
        print ('keepLayer', keepLayer)

        alg_params1 = {
            'INPUT' : input_layer,
            'OVERLAY' : keepLayer,
            'OUTPUT' : 'memory:{}'.format(keepLayerName+'_grided_cliped')
            }
        
        outMe = processing.run("native:clip", alg_params1)['OUTPUT']
        QgsProject().instance().addMapLayer(outMe)